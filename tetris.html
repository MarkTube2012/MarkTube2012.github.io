<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris</title>
    <style>
	    body {
    background-color: #121212;
    color: #ffffff;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    margin: 0;
}

canvas {
    border: 3px solid #00ffff;
    background-color: #000;
}

.score-box {
    margin-top: 10px;
    font-size: 20px;
}

.controls {
    margin-top: 10px;
    font-size: 14px;
    color: #ccc;
}

.mobile-controls {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-top: 20px;
}

.mobile-controls button {
    font-size: 20px;
    padding: 10px;
    background-color: #00ffff;
    border: none;
    cursor: pointer;
}
</style>
</head>
<body>
    <canvas id="tetrisCanvas" width="320" height="640"></canvas>
    <div class="score-box">
        <span id="scoreDisplay">–û—á–∫–∏: 0</span>
    </div>
    <div class="controls">
        –ö–µ—Ä—É–≤–∞–Ω–Ω—è: –°—Ç—Ä—ñ–ª–∫–∏
    </div>
    <div class="mobile-controls">
        <button id="left">‚óÄ</button>
        <button id="rotate">üîÑ</button>
        <button id="right">‚ñ∂</button>
        <button id="down">‚ñº</button>
    </div>
    <script>
	const canvas = document.getElementById("tetrisCanvas");
const context = canvas.getContext("2d");
const grid = 32;
const rows = 20;
const cols = 10;

const tetrominoes = [
    [[1, 1, 1, 1]],
    [[1, 1], [1, 1]],
    [[0, 1, 0], [1, 1, 1]],
    [[0, 1, 1], [1, 1, 0]],
    [[1, 1, 0], [0, 1, 1]],
    [[1, 0, 0], [1, 1, 1]],
    [[0, 0, 1], [1, 1, 1]]
];

let board = Array.from({ length: rows }, () => Array(cols).fill(0));
let currentTetromino = getRandomTetromino();
let offsetX = 3;
let offsetY = 0;
let score = 0;

function getRandomTetromino() {
    return tetrominoes[Math.floor(Math.random() * tetrominoes.length)];
}

function drawBoard() {
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            context.fillStyle = board[row][col] ? "white" : "black";
            context.fillRect(col * grid, row * grid, grid, grid);
            context.strokeStyle = "gray";
            context.strokeRect(col * grid, row * grid, grid, grid);
        }
    }
}

function drawTetromino(tetromino, offsetX, offsetY) {
    for (let row = 0; row < tetromino.length; row++) {
        for (let col = 0; col < tetromino[row].length; col++) {
            if (tetromino[row][col]) {
                context.fillStyle = "cyan";
                context.fillRect((offsetX + col) * grid, (offsetY + row) * grid, grid, grid);
                context.strokeStyle = "white";
                context.strokeRect((offsetX + col) * grid, (offsetY + row) * grid, grid, grid);
            }
        }
    }
}

function rotateTetromino(tetromino) {
    return tetromino[0].map((_, index) => 
        tetromino.map(row => row[index]).reverse()
    );
}

function collision(tetromino, x, y) {
    for (let row = 0; row < tetromino.length; row++) {
        for (let col = 0; col < tetromino[row].length; col++) {
            if (tetromino[row][col]) {
                let newX = x + col;
                let newY = y + row;
                if (newX < 0 || newX >= cols || newY >= rows || (newY >= 0 && board[newY][newX])) {
                    return true;
                }
            }
        }
    }
    return false;
}

function merge(tetromino, x, y) {
    for (let row = 0; row < tetromino.length; row++) {
        for (let col = 0; col < tetromino[row].length; col++) {
            if (tetromino[row][col]) {
                board[y + row][x + col] = 1;
            }
        }
    }
}

function clearLines() {
    outer: for (let row = rows - 1; row >= 0; row--) {
        for (let col = 0; col < cols; col++) {
            if (board[row][col] === 0) {
                continue outer;
            }
        }
        board.splice(row, 1);
        board.unshift(Array(cols).fill(0));
        score += 10;
        document.getElementById("scoreDisplay").textContent = "–û—á–∫–∏: " + score;
    }
}

document.getElementById("left").addEventListener("click", () => {
    if (!collision(currentTetromino, offsetX - 1, offsetY)) offsetX--;
});

document.getElementById("right").addEventListener("click", () => {
    if (!collision(currentTetromino, offsetX + 1, offsetY)) offsetX++;
});

document.getElementById("down").addEventListener("click", () => {
    if (!collision(currentTetromino, offsetX, offsetY + 1)) offsetY++;
});

document.getElementById("rotate").addEventListener("click", () => {
    const rotated = rotateTetromino(currentTetromino);
    if (!collision(rotated, offsetX, offsetY)) currentTetromino = rotated;
});

function gameLoop() {
    if (!collision(currentTetromino, offsetX, offsetY + 1)) {
        offsetY++;
    } else {
        merge(currentTetromino, offsetX, offsetY);
        clearLines();
        offsetX = 3;
        offsetY = 0;
        currentTetromino = getRandomTetromino();
        if (collision(currentTetromino, offsetX, offsetY)) {
            alert("Game over! Score: " + score);
            board = Array.from({ length: rows }, () => Array(cols).fill(0));
            score = 0;
            document.getElementById("scoreDisplay").textContent = "–û—á–∫–∏: " + score;
        }
    }
    context.clearRect(0, 0, canvas.width, canvas.height);
    drawBoard();
    drawTetromino(currentTetromino, offsetX, offsetY);
}

setInterval(gameLoop, 500);
	</script>
</body>
</html>